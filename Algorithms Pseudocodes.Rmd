---
title: "Pseudocode of Algorithms"
output: html_notebook
---
All pseudocodes that appeared in the Algorithms course.



#1 Basics#

Insertion Sort
```{python}
INSERTION-SORT(A,n):
for j = 2 to n
  key = A[j]
  i = j - 1
  while  i>0 and A[i]>key
    A[i+1] = A[i]
    i = i-1
  A[i+1] = key

```
$O(n^{2})$.

Linear Search
```{python}
LinSearch(A,v)
for i = 1 to length(A)
  if A[i] = v
    return i
endfor
return NIL
```
$\Theta(n)$. 

#2 Divide & Conquer!#

Merge Sort:
```{python}
MERGE(A,p,q,r):
    n1 = q - p + 1
    n2 = r - q 
    #divide into left and right arrays
    Let L,R be new arrays
    for i = 1 to n1
        L[i] = A[p + i -1]
    for j = 1 to n2
        R[j] = A[q + j]
    L[n1+1] = infinity
    R[n1+1] = infinity
    i = 1
    j = 1
    for k = p to r
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i + 1
        else:
            A[k] = R[j]
            j = j + 1

MERGE-SORT(A,p,q,r)
  if p<r               #base case
    q = floor((p+r)/2) #divide
    MERGE-SORT(A,p,q)  #conquer
    MERGESORT(A,q+1,r)
    MERGE(A,p,q,r)     #combine
```
This runs in $\Theta(n\log{n})$ time.

Slow Maximum-Subarray:
```{python}
MAXIMUM-SUBARRAY-SLOW(A)
B.val <- -\infty, B.i <- 1, B.j <- n
for i = 1 to n:
  tmp <- 0
  for j<- i to n
    tmp <- tmp + A[j]
    if tmp > B.val
      B.val <- tmp
      B.i <- i
      B.j <- j
return(B.i,B.j,B.val)
```
$\Theta(n^{2})$. $\Theta(n)$ space. We are simply checking all $nC2$ combinations!

Maximum-Subarray
```{python}

FIND-MAX-CROSSING-SUBARRAY(A,low,mid.high)
#max subarray of form A[i..mid]
left-sum = -\infty
sum = 0
for i = mid downto low
  sum  = sum + A[i]
  if sum > left-sum
    left-sum = sum
    max-left = i
  
#A[mid+1..j]
right-sum = -\infty
sum = 0
for j = mid+1 to high
  sum  = sum + A[j]
  if sum > right-sum
    right-sum = sum
    max-right = j
    
return(max-left,max-right,left-sum + right-sum)
  
  
FIND-MAXIMUM-SUBARRAY(A,low,high)
if high == low
  return (low,high,A[low]) #base case
else mid = floor((low+high)/2)
  (left-low,left-high,left-sum) = FIND-MAXIMUM-SUBARRAY(A,low,mid)
  (right-low,right-high,right-sum) = FIND-MAXIMUM-SUBARRAY(A,mid+1,high)
  (cross-low,cross-high,cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)
  if left-sum => right-sum and left-sum => cross-sum
    return (left-low,left-high,left-sum)
  else if right-sum => left-sum and right-sum => cross-sum
    return (right-low,right-high,right-sum)
  else return (cross-low,cross-high,cross-sum)

```
$\Theta(n\log{n})$. 
